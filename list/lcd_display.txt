; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\out\lcd_display.o --asm_dir=..\list\ --list_dir=..\list\ --depend=..\out\lcd_display.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\src -I..\lib\STM32F10x_StdPeriph_Driver\inc -I..\lib\CMSIS\CM3\CoreSupport -I..\lib\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DDEBUG --omf_browse=..\out\lcd_display.crf ..\src\display\lcd_display.c]
                          THUMB

                          AREA ||i.delay_s||, CODE, READONLY, ALIGN=1

                  delay_s PROC
;;;2      
;;;3      static void delay_s(uint64_t time)
000000  b530              PUSH     {r4,r5,lr}
;;;4      {
;;;5          for (; time > 0; time--);
000002  e002              B        |L1.10|
                  |L1.4|
000004  1e40              SUBS     r0,r0,#1
000006  f1610100          SBC      r1,r1,#0
                  |L1.10|
00000a  2300              MOVS     r3,#0
00000c  ea800203          EOR      r2,r0,r3
000010  404b              EORS     r3,r3,r1
000012  431a              ORRS     r2,r2,r3
000014  d1f6              BNE      |L1.4|
;;;6      }
000016  bd30              POP      {r4,r5,pc}
;;;7      
                          ENDP


                          AREA ||i.e_reset||, CODE, READONLY, ALIGN=2

                  e_reset PROC
;;;122    
;;;123    static void e_reset(void)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125        GPIO_ResetBits(LCD_DIS_PORT, E_PIN);
000002  f44f5180          MOV      r1,#0x1000
000006  4802              LDR      r0,|L2.16|
000008  f7fffffe          BL       GPIO_ResetBits
;;;126    }
00000c  bd10              POP      {r4,pc}
;;;127    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40011c00

                          AREA ||i.e_set||, CODE, READONLY, ALIGN=2

                  e_set PROC
;;;117    
;;;118    static void e_set(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120        GPIO_SetBits(LCD_DIS_PORT, E_PIN);
000002  f44f5180          MOV      r1,#0x1000
000006  4802              LDR      r0,|L3.16|
000008  f7fffffe          BL       GPIO_SetBits
;;;121    }
00000c  bd10              POP      {r4,pc}
;;;122    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40011c00

                          AREA ||i.init_lcd_display||, CODE, READONLY, ALIGN=2

                  init_lcd_display PROC
;;;7      
;;;8      void init_lcd_display(void)
000000  b508              PUSH     {r3,lr}
;;;9      {
;;;10         GPIO_InitTypeDef gpio_init_type;
;;;11         RCC_APB2PeriphClockCmd(LCD_DIS_RCC, ENABLE);
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;12         gpio_init_type.GPIO_Mode = GPIO_Mode_Out_PP;
00000a  2010              MOVS     r0,#0x10
00000c  f88d0003          STRB     r0,[sp,#3]
;;;13         gpio_init_type.GPIO_Speed = GPIO_Speed_10MHz;
000010  2001              MOVS     r0,#1
000012  f88d0002          STRB     r0,[sp,#2]
;;;14         gpio_init_type.GPIO_Pin =  RS_PIN;
000016  0200              LSLS     r0,r0,#8
000018  f8ad0000          STRH     r0,[sp,#0]
;;;15         GPIO_Init(LCD_DIS_PORT, &gpio_init_type);
00001c  4669              MOV      r1,sp
00001e  481d              LDR      r0,|L4.148|
000020  f7fffffe          BL       GPIO_Init
;;;16         gpio_init_type.GPIO_Pin =  RW_PIN;
000024  f44f6000          MOV      r0,#0x800
000028  f8ad0000          STRH     r0,[sp,#0]
;;;17         GPIO_Init(LCD_DIS_PORT, &gpio_init_type);
00002c  4669              MOV      r1,sp
00002e  4819              LDR      r0,|L4.148|
000030  f7fffffe          BL       GPIO_Init
;;;18         gpio_init_type.GPIO_Pin =  E_PIN;
000034  f44f5080          MOV      r0,#0x1000
000038  f8ad0000          STRH     r0,[sp,#0]
;;;19         GPIO_Init(LCD_DIS_PORT, &gpio_init_type);
00003c  4669              MOV      r1,sp
00003e  4815              LDR      r0,|L4.148|
000040  f7fffffe          BL       GPIO_Init
;;;20         write_cmd_byte_no_wait(0x38);
000044  2038              MOVS     r0,#0x38
000046  f7fffffe          BL       write_cmd_byte_no_wait
;;;21         delay_s(0x2FF);
00004a  f24020ff          MOV      r0,#0x2ff
00004e  2100              MOVS     r1,#0
000050  f7fffffe          BL       delay_s
;;;22         write_cmd_byte_no_wait(0x38);
000054  2038              MOVS     r0,#0x38
000056  f7fffffe          BL       write_cmd_byte_no_wait
;;;23         delay_s(0x2FF);
00005a  f24020ff          MOV      r0,#0x2ff
00005e  2100              MOVS     r1,#0
000060  f7fffffe          BL       delay_s
;;;24         write_cmd_byte_no_wait(0x38);
000064  2038              MOVS     r0,#0x38
000066  f7fffffe          BL       write_cmd_byte_no_wait
;;;25         delay_s(0x2FF);
00006a  f24020ff          MOV      r0,#0x2ff
00006e  2100              MOVS     r1,#0
000070  f7fffffe          BL       delay_s
;;;26         write_cmd_byte(0x38);
000074  2038              MOVS     r0,#0x38
000076  f7fffffe          BL       write_cmd_byte
;;;27         write_cmd_byte(0x08);
00007a  2008              MOVS     r0,#8
00007c  f7fffffe          BL       write_cmd_byte
;;;28         write_cmd_byte(0x01);
000080  2001              MOVS     r0,#1
000082  f7fffffe          BL       write_cmd_byte
;;;29         write_cmd_byte(0x06);
000086  2006              MOVS     r0,#6
000088  f7fffffe          BL       write_cmd_byte
;;;30         write_cmd_byte(0x0c);
00008c  200c              MOVS     r0,#0xc
00008e  f7fffffe          BL       write_cmd_byte
;;;31     }
000092  bd08              POP      {r3,pc}
;;;32     
                          ENDP

                  |L4.148|
                          DCD      0x40011c00

                          AREA ||i.lcd_clear_screen||, CODE, READONLY, ALIGN=1

                  lcd_clear_screen PROC
;;;201    
;;;202    void lcd_clear_screen(void)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204        write_cmd_byte(1);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       write_cmd_byte
;;;205    }
000008  bd10              POP      {r4,pc}
;;;206    
                          ENDP


                          AREA ||i.lcd_get_new_line||, CODE, READONLY, ALIGN=1

                  lcd_get_new_line PROC
;;;216    
;;;217    void lcd_get_new_line(void)
000000  b570              PUSH     {r4-r6,lr}
;;;218    {
;;;219        uint8_t addr_cur = read_status_byte();
000002  f7fffffe          BL       read_status_byte
000006  4604              MOV      r4,r0
;;;220        addr_cur &= ~BF_BIT;
000008  f0240480          BIC      r4,r4,#0x80
;;;221        int cur_line = addr_cur / one_line_memsize;
00000c  4620              MOV      r0,r4
00000e  17e1              ASRS     r1,r4,#31
000010  eb046191          ADD      r1,r4,r1,LSR #26
000014  118d              ASRS     r5,r1,#6
;;;222        lcd_set_ddram_ptr(cur_line >= hrow_num - 1 ?
000016  2d01              CMP      r5,#1
000018  db01              BLT      |L6.30|
;;;223                          (hrow_num - 1) * one_line_memsize :
00001a  2140              MOVS     r1,#0x40
00001c  e001              B        |L6.34|
                  |L6.30|
;;;224                          (cur_line + 1) * one_line_memsize);
00001e  1c69              ADDS     r1,r5,#1
000020  0189              LSLS     r1,r1,#6
                  |L6.34|
000022  b2c8              UXTB     r0,r1
000024  f7fffffe          BL       lcd_set_ddram_ptr
;;;225    }
000028  bd70              POP      {r4-r6,pc}
;;;226    
                          ENDP


                          AREA ||i.lcd_get_string||, CODE, READONLY, ALIGN=1

                  lcd_get_string PROC
;;;227    
;;;228    char* lcd_get_string(int row, int col, int num)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;229    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4692              MOV      r10,r2
;;;230        int read_count, line_count;
;;;231        uint8_t read_addr;
;;;232        char* str_buf;
;;;233    
;;;234        if (row < 0 || row >= hrow_num || col < 0
00000a  2d00              CMP      r5,#0
00000c  db05              BLT      |L7.26|
00000e  2d02              CMP      r5,#2
000010  da03              BGE      |L7.26|
000012  2e00              CMP      r6,#0
000014  db01              BLT      |L7.26|
;;;235                || col >= hcol_num)
000016  2e10              CMP      r6,#0x10
000018  db02              BLT      |L7.32|
                  |L7.26|
;;;236            return NULL;
00001a  2000              MOVS     r0,#0
                  |L7.28|
;;;237    
;;;238        if (num < hrow_num * hcol_num)
;;;239            str_buf = malloc(num + 1);
;;;240        else
;;;241            str_buf = malloc(hrow_num * hcol_num + 1);
;;;242    
;;;243        if (!str_buf)
;;;244            return NULL;
;;;245    
;;;246        read_addr = row * one_line_memsize + col;
;;;247        line_count = col;
;;;248        lcd_set_ddram_ptr(read_addr);
;;;249    
;;;250        for (read_count = 0; read_count < num; read_count++)
;;;251        {
;;;252            str_buf[read_count] = read_data_byte();
;;;253            read_addr++;
;;;254            line_count++;
;;;255    
;;;256            if (line_count >= hcol_num)
;;;257            {
;;;258                if (read_addr >= one_line_memsize * (hrow_num - 1) +
;;;259                        hcol_num)
;;;260                    break;
;;;261    
;;;262                line_count = 0;
;;;263                read_addr += one_line_memsize - hcol_num;
;;;264                lcd_set_ddram_ptr(read_addr);
;;;265            }
;;;266        }
;;;267    
;;;268        str_buf[read_count] = '\0';
;;;269        return str_buf;
;;;270    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L7.32|
000020  f1ba0f20          CMP      r10,#0x20             ;238
000024  da05              BGE      |L7.50|
000026  f10a0001          ADD      r0,r10,#1             ;239
00002a  f7fffffe          BL       malloc
00002e  4604              MOV      r4,r0                 ;239
000030  e003              B        |L7.58|
                  |L7.50|
000032  2021              MOVS     r0,#0x21              ;241
000034  f7fffffe          BL       malloc
000038  4604              MOV      r4,r0                 ;241
                  |L7.58|
00003a  b90c              CBNZ     r4,|L7.64|
00003c  2000              MOVS     r0,#0                 ;244
00003e  e7ed              B        |L7.28|
                  |L7.64|
000040  eb061085          ADD      r0,r6,r5,LSL #6       ;246
000044  f00008ff          AND      r8,r0,#0xff           ;246
000048  46b1              MOV      r9,r6                 ;247
00004a  4640              MOV      r0,r8                 ;248
00004c  f7fffffe          BL       lcd_set_ddram_ptr
000050  2700              MOVS     r7,#0                 ;250
000052  e019              B        |L7.136|
                  |L7.84|
000054  f7fffffe          BL       read_data_byte
000058  55e0              STRB     r0,[r4,r7]            ;252
00005a  f1080001          ADD      r0,r8,#1              ;253
00005e  f00008ff          AND      r8,r0,#0xff           ;253
000062  f1090901          ADD      r9,r9,#1              ;254
000066  f1b90f10          CMP      r9,#0x10              ;256
00006a  db0c              BLT      |L7.134|
00006c  f1b80f50          CMP      r8,#0x50              ;258
000070  db00              BLT      |L7.116|
000072  e00b              B        |L7.140|
                  |L7.116|
000074  f04f0900          MOV      r9,#0                 ;262
000078  f1080030          ADD      r0,r8,#0x30           ;263
00007c  f00008ff          AND      r8,r0,#0xff           ;263
000080  4640              MOV      r0,r8                 ;264
000082  f7fffffe          BL       lcd_set_ddram_ptr
                  |L7.134|
000086  1c7f              ADDS     r7,r7,#1              ;250
                  |L7.136|
000088  4557              CMP      r7,r10                ;250
00008a  dbe3              BLT      |L7.84|
                  |L7.140|
00008c  bf00              NOP                            ;260
00008e  2000              MOVS     r0,#0                 ;268
000090  55e0              STRB     r0,[r4,r7]            ;268
000092  4620              MOV      r0,r4                 ;269
000094  e7c2              B        |L7.28|
;;;271    
                          ENDP


                          AREA ||i.lcd_print||, CODE, READONLY, ALIGN=1

                  lcd_print PROC
;;;314    
;;;315    void lcd_print(char* string, int row, int col)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;316    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;317        int row_iter, print_count = 0;
00000a  f04f0800          MOV      r8,#0
;;;318        size_t slen;
;;;319    
;;;320        if (row < 0 || row >= hrow_num || col < 0
00000e  2c00              CMP      r4,#0
000010  db05              BLT      |L8.30|
000012  2c02              CMP      r4,#2
000014  da03              BGE      |L8.30|
000016  2d00              CMP      r5,#0
000018  db01              BLT      |L8.30|
;;;321                || col >= hcol_num)
00001a  2d10              CMP      r5,#0x10
00001c  db01              BLT      |L8.34|
                  |L8.30|
;;;322            return;
;;;323    
;;;324        slen = strlen(string);
;;;325    
;;;326        for (row_iter = row; row_iter < hrow_num; row_iter++)
;;;327        {
;;;328            if (row_iter == row)
;;;329            {
;;;330                lcd_print_line(string, row, col);
;;;331                print_count += hcol_num - col;
;;;332                string += hcol_num - col;
;;;333            }
;;;334            else
;;;335            {
;;;336                lcd_print_line(string, row_iter, 0);
;;;337                print_count += hcol_num;
;;;338                string += hcol_num;
;;;339            }
;;;340    
;;;341            if (print_count >= slen)
;;;342                break;
;;;343        }
;;;344    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L8.34|
000022  4638              MOV      r0,r7                 ;324
000024  f7fffffe          BL       strlen
000028  4681              MOV      r9,r0                 ;324
00002a  4626              MOV      r6,r4                 ;326
00002c  e019              B        |L8.98|
                  |L8.46|
00002e  42a6              CMP      r6,r4                 ;328
000030  d10b              BNE      |L8.74|
000032  462a              MOV      r2,r5                 ;330
000034  4621              MOV      r1,r4                 ;330
000036  4638              MOV      r0,r7                 ;330
000038  f7fffffe          BL       lcd_print_line
00003c  f1c50010          RSB      r0,r5,#0x10           ;331
000040  4480              ADD      r8,r8,r0              ;331
000042  f1c50010          RSB      r0,r5,#0x10           ;332
000046  4407              ADD      r7,r7,r0              ;332
000048  e007              B        |L8.90|
                  |L8.74|
00004a  2200              MOVS     r2,#0                 ;336
00004c  4631              MOV      r1,r6                 ;336
00004e  4638              MOV      r0,r7                 ;336
000050  f7fffffe          BL       lcd_print_line
000054  f1080810          ADD      r8,r8,#0x10           ;337
000058  3710              ADDS     r7,r7,#0x10           ;338
                  |L8.90|
00005a  45c8              CMP      r8,r9                 ;341
00005c  d300              BCC      |L8.96|
00005e  e002              B        |L8.102|
                  |L8.96|
000060  1c76              ADDS     r6,r6,#1              ;326
                  |L8.98|
000062  2e02              CMP      r6,#2                 ;326
000064  dbe3              BLT      |L8.46|
                  |L8.102|
000066  bf00              NOP                            ;342
000068  bf00              NOP      
00006a  e7d8              B        |L8.30|
;;;345    
                          ENDP


                          AREA ||i.lcd_print_line||, CODE, READONLY, ALIGN=1

                  lcd_print_line PROC
;;;272    
;;;273    void lcd_print_line(char* string, int row, int col)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;274    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;275        int display_offset, display_num, i;
;;;276    
;;;277        if (row < 0 || row >= hrow_num || col < 0
00000a  2c00              CMP      r4,#0
00000c  db05              BLT      |L9.26|
00000e  2c02              CMP      r4,#2
000010  da03              BGE      |L9.26|
000012  2d00              CMP      r5,#0
000014  db01              BLT      |L9.26|
;;;278                || col >= hcol_num)
000016  2d10              CMP      r5,#0x10
000018  db01              BLT      |L9.30|
                  |L9.26|
;;;279            return;
;;;280    
;;;281        display_offset = row * one_line_memsize + col;
;;;282        display_num = hcol_num - col;
;;;283        lcd_set_ddram_ptr(display_offset);
;;;284    
;;;285        for (i = 0; i < display_num; i++)
;;;286        {
;;;287            if (string[i] == '\0')
;;;288                break;
;;;289    
;;;290            write_data_byte(string[i]);
;;;291        }
;;;292    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L9.30|
00001e  eb051884          ADD      r8,r5,r4,LSL #6       ;281
000022  f1c50910          RSB      r9,r5,#0x10           ;282
000026  f00800ff          AND      r0,r8,#0xff           ;283
00002a  f7fffffe          BL       lcd_set_ddram_ptr
00002e  2600              MOVS     r6,#0                 ;285
000030  e006              B        |L9.64|
                  |L9.50|
000032  5db8              LDRB     r0,[r7,r6]            ;287
000034  b900              CBNZ     r0,|L9.56|
000036  e005              B        |L9.68|
                  |L9.56|
000038  5db8              LDRB     r0,[r7,r6]            ;290
00003a  f7fffffe          BL       write_data_byte
00003e  1c76              ADDS     r6,r6,#1              ;285
                  |L9.64|
000040  454e              CMP      r6,r9                 ;285
000042  dbf6              BLT      |L9.50|
                  |L9.68|
000044  bf00              NOP                            ;288
000046  bf00              NOP      
000048  e7e7              B        |L9.26|
;;;293    
                          ENDP


                          AREA ||i.lcd_print_line_with_num||, CODE, READONLY, ALIGN=1

                  lcd_print_line_with_num PROC
;;;293    
;;;294    void lcd_print_line_with_num(char* string, int row, int col,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;295                                 int num)
;;;296    {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;297        int need_clear_num = 0, i;
00000c  f04f0a00          MOV      r10,#0
;;;298        size_t slen = strlen(string);
000010  4640              MOV      r0,r8
000012  f7fffffe          BL       strlen
000016  4681              MOV      r9,r0
;;;299    
;;;300        if (row < 0 || row >= hrow_num || col < 0
000018  2d00              CMP      r5,#0
00001a  db05              BLT      |L10.40|
00001c  2d02              CMP      r5,#2
00001e  da03              BGE      |L10.40|
000020  2e00              CMP      r6,#0
000022  db01              BLT      |L10.40|
;;;301                || col >= hcol_num)
000024  2e10              CMP      r6,#0x10
000026  db01              BLT      |L10.44|
                  |L10.40|
;;;302            return;
;;;303    
;;;304        if (slen > num)
;;;305            string[num] = '\0';
;;;306        else
;;;307            need_clear_num = num - slen;
;;;308    
;;;309        lcd_print_line(string, row, col);
;;;310    
;;;311        for (i = 0; i < need_clear_num; i++)
;;;312            write_data_byte(' ');
;;;313    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L10.44|
00002c  45a1              CMP      r9,r4                 ;304
00002e  d903              BLS      |L10.56|
000030  2000              MOVS     r0,#0                 ;305
000032  f8080004          STRB     r0,[r8,r4]            ;305
000036  e001              B        |L10.60|
                  |L10.56|
000038  eba40a09          SUB      r10,r4,r9             ;307
                  |L10.60|
00003c  4632              MOV      r2,r6                 ;309
00003e  4629              MOV      r1,r5                 ;309
000040  4640              MOV      r0,r8                 ;309
000042  f7fffffe          BL       lcd_print_line
000046  2700              MOVS     r7,#0                 ;311
000048  e003              B        |L10.82|
                  |L10.74|
00004a  2020              MOVS     r0,#0x20              ;312
00004c  f7fffffe          BL       write_data_byte
000050  1c7f              ADDS     r7,r7,#1              ;311
                  |L10.82|
000052  4557              CMP      r7,r10                ;311
000054  dbf9              BLT      |L10.74|
000056  bf00              NOP      
000058  e7e6              B        |L10.40|
;;;314    
                          ENDP


                          AREA ||i.lcd_set_ddram_ptr||, CODE, READONLY, ALIGN=1

                  lcd_set_ddram_ptr PROC
;;;206    
;;;207    void lcd_set_ddram_ptr(uint8_t addr)
000000  b510              PUSH     {r4,lr}
;;;208    {
000002  4604              MOV      r4,r0
;;;209        if (addr > lcd_ddram_memsize_max - 1)
000004  2c67              CMP      r4,#0x67
000006  dd00              BLE      |L11.10|
                  |L11.8|
;;;210            return;
;;;211        
;;;212        addr |= 0b10000000;
;;;213    
;;;214        write_cmd_byte(addr);
;;;215    }
000008  bd10              POP      {r4,pc}
                  |L11.10|
00000a  f0440480          ORR      r4,r4,#0x80           ;212
00000e  4620              MOV      r0,r4                 ;214
000010  f7fffffe          BL       write_cmd_byte
000014  bf00              NOP      
000016  e7f7              B        |L11.8|
;;;216    
                          ENDP


                          AREA ||i.read_data||, CODE, READONLY, ALIGN=2

                  read_data PROC
;;;68     
;;;69     static uint8_t read_data(void)
000000  b510              PUSH     {r4,lr}
;;;70     {
;;;71         start_read_data();
000002  f7fffffe          BL       start_read_data
;;;72         uint8_t data = (0xFF & GPIO_ReadInputData(LCD_DIS_PORT));
000006  4803              LDR      r0,|L12.20|
000008  f7fffffe          BL       GPIO_ReadInputData
00000c  b2c4              UXTB     r4,r0
;;;73         return data;
00000e  4620              MOV      r0,r4
;;;74     }
000010  bd10              POP      {r4,pc}
;;;75     
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40011c00

                          AREA ||i.read_data_byte||, CODE, READONLY, ALIGN=1

                  read_data_byte PROC
;;;147    
;;;148    uint8_t read_data_byte(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150        uint8_t data;
;;;151        wait_bf();
000002  f7fffffe          BL       wait_bf
;;;152        rs_set();
000006  f7fffffe          BL       rs_set
;;;153        rw_set();
00000a  f7fffffe          BL       rw_set
;;;154        delay_s(0x10);
00000e  2010              MOVS     r0,#0x10
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       delay_s
;;;155        e_set();
000016  f7fffffe          BL       e_set
;;;156        delay_s(0x40);
00001a  2040              MOVS     r0,#0x40
00001c  2100              MOVS     r1,#0
00001e  f7fffffe          BL       delay_s
;;;157        data = read_data();
000022  f7fffffe          BL       read_data
000026  4604              MOV      r4,r0
;;;158        delay_s(0x10);
000028  2010              MOVS     r0,#0x10
00002a  2100              MOVS     r1,#0
00002c  f7fffffe          BL       delay_s
;;;159        e_reset();
000030  f7fffffe          BL       e_reset
;;;160        return data;
000034  4620              MOV      r0,r4
;;;161    }
000036  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.read_status_byte||, CODE, READONLY, ALIGN=1

                  read_status_byte PROC
;;;133    
;;;134    uint8_t read_status_byte(void)
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136        uint8_t data;
;;;137        rs_reset();
000002  f7fffffe          BL       rs_reset
;;;138        rw_set();
000006  f7fffffe          BL       rw_set
;;;139        delay_s(0x10);
00000a  2010              MOVS     r0,#0x10
00000c  2100              MOVS     r1,#0
00000e  f7fffffe          BL       delay_s
;;;140        e_set();
000012  f7fffffe          BL       e_set
;;;141        delay_s(0x40);
000016  2040              MOVS     r0,#0x40
000018  2100              MOVS     r1,#0
00001a  f7fffffe          BL       delay_s
;;;142        data = read_data();
00001e  f7fffffe          BL       read_data
000022  4604              MOV      r4,r0
;;;143        delay_s(0x10);
000024  2010              MOVS     r0,#0x10
000026  2100              MOVS     r1,#0
000028  f7fffffe          BL       delay_s
;;;144        e_reset();
00002c  f7fffffe          BL       e_reset
;;;145        return data;
000030  4620              MOV      r0,r4
;;;146    }
000032  bd10              POP      {r4,pc}
;;;147    
                          ENDP


                          AREA ||i.rs_reset||, CODE, READONLY, ALIGN=2

                  rs_reset PROC
;;;102    
;;;103    static void rs_reset(void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105        GPIO_ResetBits(LCD_DIS_PORT, RS_PIN);
000002  f44f7180          MOV      r1,#0x100
000006  4802              LDR      r0,|L15.16|
000008  f7fffffe          BL       GPIO_ResetBits
;;;106    }
00000c  bd10              POP      {r4,pc}
;;;107    
                          ENDP

00000e  0000              DCW      0x0000
                  |L15.16|
                          DCD      0x40011c00

                          AREA ||i.rs_set||, CODE, READONLY, ALIGN=2

                  rs_set PROC
;;;97     
;;;98     static void rs_set(void)
000000  b510              PUSH     {r4,lr}
;;;99     {
;;;100        GPIO_SetBits(LCD_DIS_PORT, RS_PIN);
000002  f44f7180          MOV      r1,#0x100
000006  4802              LDR      r0,|L16.16|
000008  f7fffffe          BL       GPIO_SetBits
;;;101    }
00000c  bd10              POP      {r4,pc}
;;;102    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40011c00

                          AREA ||i.rw_reset||, CODE, READONLY, ALIGN=2

                  rw_reset PROC
;;;112    
;;;113    static void rw_reset(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115        GPIO_ResetBits(LCD_DIS_PORT, RW_PIN);
000002  f44f6100          MOV      r1,#0x800
000006  4802              LDR      r0,|L17.16|
000008  f7fffffe          BL       GPIO_ResetBits
;;;116    }
00000c  bd10              POP      {r4,pc}
;;;117    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40011c00

                          AREA ||i.rw_set||, CODE, READONLY, ALIGN=2

                  rw_set PROC
;;;107    
;;;108    static void rw_set(void)
000000  b510              PUSH     {r4,lr}
;;;109    {
;;;110        GPIO_SetBits(LCD_DIS_PORT, RW_PIN);
000002  f44f6100          MOV      r1,#0x800
000006  4802              LDR      r0,|L18.16|
000008  f7fffffe          BL       GPIO_SetBits
;;;111    }
00000c  bd10              POP      {r4,pc}
;;;112    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40011c00

                          AREA ||i.set_data_pin_gpio||, CODE, READONLY, ALIGN=2

                  set_data_pin_gpio PROC
;;;32     
;;;33     static void set_data_pin_gpio(GPIO_InitTypeDef*
000000  b510              PUSH     {r4,lr}
;;;34                                   gpio_init_type)
;;;35     {
000002  4604              MOV      r4,r0
;;;36         gpio_init_type->GPIO_Pin =  D0_PIN;
000004  2001              MOVS     r0,#1
000006  8020              STRH     r0,[r4,#0]
;;;37         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
000008  4621              MOV      r1,r4
00000a  4817              LDR      r0,|L19.104|
00000c  f7fffffe          BL       GPIO_Init
;;;38         gpio_init_type->GPIO_Pin =  D1_PIN;
000010  2002              MOVS     r0,#2
000012  8020              STRH     r0,[r4,#0]
;;;39         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
000014  4621              MOV      r1,r4
000016  4814              LDR      r0,|L19.104|
000018  f7fffffe          BL       GPIO_Init
;;;40         gpio_init_type->GPIO_Pin =  D2_PIN;
00001c  2004              MOVS     r0,#4
00001e  8020              STRH     r0,[r4,#0]
;;;41         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
000020  4621              MOV      r1,r4
000022  4811              LDR      r0,|L19.104|
000024  f7fffffe          BL       GPIO_Init
;;;42         gpio_init_type->GPIO_Pin =  D3_PIN;
000028  2008              MOVS     r0,#8
00002a  8020              STRH     r0,[r4,#0]
;;;43         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
00002c  4621              MOV      r1,r4
00002e  480e              LDR      r0,|L19.104|
000030  f7fffffe          BL       GPIO_Init
;;;44         gpio_init_type->GPIO_Pin =  D4_PIN;
000034  2010              MOVS     r0,#0x10
000036  8020              STRH     r0,[r4,#0]
;;;45         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
000038  4621              MOV      r1,r4
00003a  480b              LDR      r0,|L19.104|
00003c  f7fffffe          BL       GPIO_Init
;;;46         gpio_init_type->GPIO_Pin =  D5_PIN;
000040  2020              MOVS     r0,#0x20
000042  8020              STRH     r0,[r4,#0]
;;;47         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
000044  4621              MOV      r1,r4
000046  4808              LDR      r0,|L19.104|
000048  f7fffffe          BL       GPIO_Init
;;;48         gpio_init_type->GPIO_Pin =  D6_PIN;
00004c  2040              MOVS     r0,#0x40
00004e  8020              STRH     r0,[r4,#0]
;;;49         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
000050  4621              MOV      r1,r4
000052  4805              LDR      r0,|L19.104|
000054  f7fffffe          BL       GPIO_Init
;;;50         gpio_init_type->GPIO_Pin =  D7_PIN;
000058  2080              MOVS     r0,#0x80
00005a  8020              STRH     r0,[r4,#0]
;;;51         GPIO_Init(LCD_DIS_PORT, gpio_init_type);
00005c  4621              MOV      r1,r4
00005e  4802              LDR      r0,|L19.104|
000060  f7fffffe          BL       GPIO_Init
;;;52     }
000064  bd10              POP      {r4,pc}
;;;53     
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      0x40011c00

                          AREA ||i.start_read_data||, CODE, READONLY, ALIGN=1

                  start_read_data PROC
;;;53     
;;;54     static void start_read_data(void)
000000  b508              PUSH     {r3,lr}
;;;55     {
;;;56         GPIO_InitTypeDef gpio_init_type;
;;;57         gpio_init_type.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000002  2004              MOVS     r0,#4
000004  f88d0003          STRB     r0,[sp,#3]
;;;58         set_data_pin_gpio(&gpio_init_type);
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       set_data_pin_gpio
;;;59     }
00000e  bd08              POP      {r3,pc}
;;;60     
                          ENDP


                          AREA ||i.start_write_data||, CODE, READONLY, ALIGN=1

                  start_write_data PROC
;;;60     
;;;61     static void start_write_data(void)
000000  b508              PUSH     {r3,lr}
;;;62     {
;;;63         GPIO_InitTypeDef gpio_init_type;
;;;64         gpio_init_type.GPIO_Mode = GPIO_Mode_Out_PP;
000002  2010              MOVS     r0,#0x10
000004  f88d0003          STRB     r0,[sp,#3]
;;;65         gpio_init_type.GPIO_Speed = GPIO_Speed_10MHz;
000008  2001              MOVS     r0,#1
00000a  f88d0002          STRB     r0,[sp,#2]
;;;66         set_data_pin_gpio(&gpio_init_type);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       set_data_pin_gpio
;;;67     }
000014  bd08              POP      {r3,pc}
;;;68     
                          ENDP


                          AREA ||i.wait_bf||, CODE, READONLY, ALIGN=1

                  wait_bf PROC
;;;127    
;;;128    static void wait_bf(void)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130        while (read_status_byte() & BF_BIT);
000002  bf00              NOP      
                  |L22.4|
000004  f7fffffe          BL       read_status_byte
000008  f0000080          AND      r0,r0,#0x80
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L22.4|
;;;131    }
000010  bd10              POP      {r4,pc}
;;;132    
                          ENDP


                          AREA ||i.write_cmd_byte||, CODE, READONLY, ALIGN=1

                  write_cmd_byte PROC
;;;162    
;;;163    void write_cmd_byte(uint8_t data)
000000  b510              PUSH     {r4,lr}
;;;164    {
000002  4604              MOV      r4,r0
;;;165        wait_bf();
000004  f7fffffe          BL       wait_bf
;;;166        rs_reset();
000008  f7fffffe          BL       rs_reset
;;;167        rw_reset();
00000c  f7fffffe          BL       rw_reset
;;;168        write_data(data);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       write_data
;;;169        delay_s(0x30);
000016  2030              MOVS     r0,#0x30
000018  2100              MOVS     r1,#0
00001a  f7fffffe          BL       delay_s
;;;170        e_set();
00001e  f7fffffe          BL       e_set
;;;171        delay_s(0x40);
000022  2040              MOVS     r0,#0x40
000024  2100              MOVS     r1,#0
000026  f7fffffe          BL       delay_s
;;;172        e_reset();
00002a  f7fffffe          BL       e_reset
;;;173        delay_s(0x10);
00002e  2010              MOVS     r0,#0x10
000030  2100              MOVS     r1,#0
000032  f7fffffe          BL       delay_s
;;;174    }
000036  bd10              POP      {r4,pc}
;;;175    
                          ENDP


                          AREA ||i.write_cmd_byte_no_wait||, CODE, READONLY, ALIGN=1

                  write_cmd_byte_no_wait PROC
;;;175    
;;;176    void write_cmd_byte_no_wait(uint8_t data)
000000  b510              PUSH     {r4,lr}
;;;177    {
000002  4604              MOV      r4,r0
;;;178        rs_reset();
000004  f7fffffe          BL       rs_reset
;;;179        rw_reset();
000008  f7fffffe          BL       rw_reset
;;;180        write_data(data);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       write_data
;;;181        delay_s(0x30);
000012  2030              MOVS     r0,#0x30
000014  2100              MOVS     r1,#0
000016  f7fffffe          BL       delay_s
;;;182        e_set();
00001a  f7fffffe          BL       e_set
;;;183        delay_s(0x40);
00001e  2040              MOVS     r0,#0x40
000020  2100              MOVS     r1,#0
000022  f7fffffe          BL       delay_s
;;;184        e_reset();
000026  f7fffffe          BL       e_reset
;;;185        delay_s(0x10);
00002a  2010              MOVS     r0,#0x10
00002c  2100              MOVS     r1,#0
00002e  f7fffffe          BL       delay_s
;;;186    }
000032  bd10              POP      {r4,pc}
;;;187    
                          ENDP


                          AREA ||i.write_data||, CODE, READONLY, ALIGN=2

                  write_data PROC
;;;75     
;;;76     static void write_data(uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;77     {
000002  4605              MOV      r5,r0
;;;78         start_write_data();
000004  f7fffffe          BL       start_write_data
;;;79         int time = 0;
000008  2400              MOVS     r4,#0
;;;80     
;;;81         for (; time < 8; time++)
00000a  e018              B        |L25.62|
                  |L25.12|
;;;82         {
;;;83             switch (data & 1)
00000c  f0050001          AND      r0,r5,#1
000010  b110              CBZ      r0,|L25.24|
000012  2801              CMP      r0,#1
000014  d110              BNE      |L25.56|
000016  e007              B        |L25.40|
                  |L25.24|
;;;84             {
;;;85             case 0:
;;;86                 GPIO_WriteBit(LCD_DIS_PORT, 1 << time, Bit_RESET);
000018  2001              MOVS     r0,#1
00001a  40a0              LSLS     r0,r0,r4
00001c  b281              UXTH     r1,r0
00001e  2200              MOVS     r2,#0
000020  4808              LDR      r0,|L25.68|
000022  f7fffffe          BL       GPIO_WriteBit
;;;87                 break;
000026  e007              B        |L25.56|
                  |L25.40|
;;;88     
;;;89             case 1:
;;;90                 GPIO_WriteBit(LCD_DIS_PORT, 1 << time, Bit_SET);
000028  2001              MOVS     r0,#1
00002a  40a0              LSLS     r0,r0,r4
00002c  b281              UXTH     r1,r0
00002e  2201              MOVS     r2,#1
000030  4804              LDR      r0,|L25.68|
000032  f7fffffe          BL       GPIO_WriteBit
;;;91                 break;
000036  bf00              NOP      
                  |L25.56|
000038  bf00              NOP                            ;87
;;;92             }
;;;93     
;;;94             data >>= 1;
00003a  106d              ASRS     r5,r5,#1
00003c  1c64              ADDS     r4,r4,#1              ;81
                  |L25.62|
00003e  2c08              CMP      r4,#8                 ;81
000040  dbe4              BLT      |L25.12|
;;;95         }
;;;96     }
000042  bd70              POP      {r4-r6,pc}
;;;97     
                          ENDP

                  |L25.68|
                          DCD      0x40011c00

                          AREA ||i.write_data_byte||, CODE, READONLY, ALIGN=1

                  write_data_byte PROC
;;;187    
;;;188    void write_data_byte(uint8_t data)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  4604              MOV      r4,r0
;;;190        wait_bf();
000004  f7fffffe          BL       wait_bf
;;;191        rs_set();
000008  f7fffffe          BL       rs_set
;;;192        rw_reset();
00000c  f7fffffe          BL       rw_reset
;;;193        write_data(data);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       write_data
;;;194        delay_s(0x30);
000016  2030              MOVS     r0,#0x30
000018  2100              MOVS     r1,#0
00001a  f7fffffe          BL       delay_s
;;;195        e_set();
00001e  f7fffffe          BL       e_set
;;;196        delay_s(0x40);
000022  2040              MOVS     r0,#0x40
000024  2100              MOVS     r1,#0
000026  f7fffffe          BL       delay_s
;;;197        e_reset();
00002a  f7fffffe          BL       e_reset
;;;198        delay_s(0x10);
00002e  2010              MOVS     r0,#0x10
000030  2100              MOVS     r1,#0
000032  f7fffffe          BL       delay_s
;;;199    }
000036  bd10              POP      {r4,pc}
;;;200    
                          ENDP

